## weaves

## GAM functions

require("mgcv")
require("car")
require("ggplot2")
require("grid")


## Some functions

hcc.chart <- function(gam1, ctr0="unknown", nocoef=FALSE, tbl=data0,
                      c0=c("value", "dt0"), name1="enqs") {

    ## Number of coefficients
    if (!nocoef) {
    l0 <- length(unique(gsub("\\.[0-9]+$", "", names(gam1$coefficients))))

    layout(matrix(1:l0, nrow = 1))
    plot(gam1)
    }

    x.df1 <- tbl
    if (is.null(tbl)) {
        x.df1 <- (gam1$model)[, 1, drop = FALSE]
        x.df1[, c0[[2]] ] <- rownames(x.df1)
        colnames(x.df1)[1] <- c0[1]
    } else {
        x.df1 <- tbl[, c0]
    }
    x.df1$type <- "Real"

    x.df2 <- data.frame(value = gam1$fitted.values, 
                        dt0 = x.df1[, c0[[2]] ] )
    x.df2$type <- "Fitted"

    datas <- rbind(x.df1, x.df2)

    ggplot(data = datas, aes(dt0, value, group = type, colour = type)) +
        geom_line(size = 0.8) +
        theme_bw() +
        labs(x = "date", y = name1,
             title = sprintf("Fit from GAM - %s", gam1[["name0"]]))

}

hcc.chart1 <- function(real0, fitted0, c0=c("value", "dt0"), 
                       name0="Predictions", name1="enqs") {

    x.df1 <- real0[, c0]
    x.df1$type <- "Real"

    x.df2 <- fitted0[, c0]
    x.df2$type <- "Predicted"

    datas <<- rbind(x.df1, x.df2)

    ## TODO could this use aes_string()?

    ggplot(data = datas, aes(dt0, value, group = type, colour = type)) +
        geom_line(size = 0.8) +
        theme_bw() +
        labs(x = "date", y = name1,
             title = sprintf("Predictions from GAM - %s", name0))

}

## Loads a set of weather predictions with blanks for other quantities.
## Writes it back with the predictions.
## Can't use deltas on the denqs
##
## Relies on ytag to name the column to predict. hcc0[["outcomen"]]
hcc.predict1 <- function(gam0, ytag="enqs", ftres=NULL,
                         src0=data0, fls=c("left.csv", "right.csv")) {
    if (is.null(ftres)) {
        ftres <- gam0$ftres
    }

    ## Blanks just weather
    pdf2 <- read.csv(fls[1])
    c00 <- colnames(pdf2)
    c0 <- colnames(pdf2)
    c0[c0 == ytag] <- "value"
    colnames(pdf2) <- c0

    dtag <- sprintf("d%s", ytag)

    pdf2[["value"]] <- predict(gam0, pdf2)

    if (gam0$family$link == "log") {
        pdf2$value <- exp(pdf2$value)
    }

    hcc.chart1(src0, pdf2, name0=gam0$name, name1=ytag)

    ## Write it back with the predictions.
    colnames(pdf2) <- c00

    write.csv(pdf2, file=fls[2], row.names=FALSE)

    return(pdf2)
}

hcc.gamS <- function(gam1, zz="all.Rout", force0=FALSE) {
    if (force0) {
        unlink(zz, force=force0)
        fl <- file(zz, "wt")
    }
    
    x.gam <- gam1
    zz <- file(zz, open = "at")
    sink(zz)
    cat("\n\n")
    cat(sprintf("start: %s", x.gam$name), "\n")
    ## what to look at: summary: EDF, p-values, R^2, GCV; AIC, magic
    cat("summary: ")
    print(summary(x.gam))

    cat("R^2: ", summary(x.gam)$r.sq, "; ")

    cat("GCV: ", summary(x.gam)$sp.criterion, "; ")

    cat("AIC: ", x.gam$aic, "; ")

    cat("BIC: ", BIC(x.gam))
    cat("\n")

    # sink(zz, type = "message")
    ## revert output back to the console -- only then access the file!
    ## sink(type = "message")
    sink()
    return(zz)
}

## From Rscript get the script name
hcc.rscript <- function() {
    args = commandArgs(trailingOnly=FALSE) # "--file=cargs.R"

    idx <- grepl("^--file=", args)
    if (!any(idx)) {
        return("")
    }
    snm <- args[ which(idx) ]
    snm <- strsplit(snm, "=")
    snm <- snm[[1]][[2]]
    return(snm)
}

hcc.paste0 <- function(x, bs0="ps") {
    return(sprintf("s(%s, bs=\"%s\")", x, bs0))
}

hcc.paste1 <- function(x, dr0="mm1", bs0="ps", bs1="cr") {
    return(sprintf("te(%s, %s, bs=c(\"%s\", \"%s\"))", x, dr0, bs1, bs0))
}

## Build a feature set with our dependent income at the start.
hcc.ftres1 <- function(hcc0) {
    nzv0 <- hcc0[["nzv"]]
    hcc0[["nzv.vars"]] <- rownames(with(nzv0, nzv0[ nzv | zeroVar, ]))

    hcc0[["discard"]] <- c(dtypes, types, hcc0[["outcomen"]], hcc0[["nzv.vars"]])
    hcc0[["discard"]] <- setdiff(hcc0[["discard"]], hcc0[["x"]])

    hcc0[["features"]] <- setdiff(hcc0[["corr.high1"]], hcc0[["discard"]])
    hcc0[["features"]] <- append(hcc0[["x"]], hcc0[["features"]])
    hcc0[["features"]] <- unique(append(hcc0[["features"]], hcc0[["dts"]]))
    return(hcc0)
}


### Claims from Enquiries

## This is generated by 2csv. Joins in the weather.
## Pre-processed 
load("hcc00.dat", envir=.GlobalEnv)

stopifnot(exists("hcc"))
data0 <- hcc
rm("hcc")

## Generic classes for attributes
c0 <- colnames(data0)
idx <- which(grepl("^action1", c0)):which(grepl("^enqrs", c0))
types <- c0[idx]
dtypes <- sapply(types, function(x) sprintf("d%s", x), USE.NAMES=FALSE)

c0 <- colnames(data0)
c0 <- intersect(c0, c("action1", "enq1s", "enqr1s"))
types1 <- c0
dtypes1 <- sapply(types1, function(x) sprintf("d%s", x), USE.NAMES=FALSE)

c0 <- colnames(data0)
c0 <- intersect(c0, c("action1", "enq2s", "enqr2s"))
types2 <- c0
dtypes2 <- sapply(types2, function(x) sprintf("d%s", x), USE.NAMES=FALSE)

types0 <- c(types, types1, types2)
dtypes0 <- c(dtypes, dtypes1, dtypes2)

c0 <- colnames(data0)
idx <- which(grepl("^tmax", c0)):which(grepl("^rain", c0))
wthrs <- c0[idx]
dwthrs <- sapply(wthrs, function(x) sprintf("d%s", x), USE.NAMES=FALSE)

dts <- c("mm1")

dt0 <- c("dt0")

## Just to check
xcld <- c(types, wthrs, dtypes, dwthrs, dts)
xcld <- setdiff(colnames(data0), xcld)
xcld

hcc.files <- NULL

## if you want to pass custom arguments, place before the script.

if (!exists("x.args")) {
    x.args = commandArgs(trailingOnly=TRUE)
}

if (length(x.args) >= 2) {
    hcc.files <- c(x.args[1], x.args[2])
}

## Oddly, these don't need to be reversed. This suggests, the enquiries are
## becoming more independent from the weather.
wts.flat <- rep(1, dim(data0)[1])

wts.exp <- ewma(c(1, rep(0, length(wts.flat) - 1)), lambda=1-0.90)
wts.expmean <- wts.exp / mean(wts.exp)

wts <- wts.flat

